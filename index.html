<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Êâ´Èõ∑Ê∏∏Êàè</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: #000;
            color: #fff;
            padding: 10px;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a1a 0%, #000 100%);
        }
        .container {
            max-width: 100%;
            margin: 0 auto;
        }
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 10px 15px;
            background: #c0c0c0;
            border: 3px outset #c0c0c0;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .mines-counter, .timer {
            font-family: 'Digital', monospace;
            background: #000;
            color: #f00;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            min-width: 80px;
            text-align: center;
            border: 2px inset #c0c0c0;
        }
        .smiley-btn {
            width: 45px;
            height: 45px;
            font-size: 20px;
            border: 3px outset #c0c0c0;
            border-radius: 6px;
            background: #c0c0c0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
        }
        .smiley-btn:active {
            border: 3px inset #c0c0c0;
        }
        .game-area {
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        /* –û–ë–ù–û–í–õ–Å–ù–ù–û–ï –ü–û–õ–ï - –ø–∏–∫—Å–µ–ª—å–Ω–æ–µ –∫–∞–∫ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª–µ */
        .field {
            display: inline-grid;
            gap: 0; /* –£–ë–†–ê–¢–¨ –ø—Ä–æ–º–µ–∂—É—Ç–∫–∏ –º–µ–∂–¥—É –∫–ª–µ—Ç–∫–∞–º–∏ */
            background: #a0a0a0; /* –°–ï–†–´–ô —Ñ–æ–Ω –∫–∞–∫ –≤ Windows */
            padding: 8px;
            border: 4px outset #a0a0a0; /* –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è 3D –≥—Ä–∞–Ω–∏—Ü–∞ */
            margin: 0 auto;
        }
        .cell {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #a0a0a0; /* –°–ï–†–´–ô —Ñ–æ–Ω */
            border: 2px outset #c0c0c0; /* 3D —ç—Ñ—Ñ–µ–∫—Ç –≤—ã–ø—É–∫–ª–æ–π –∫–Ω–æ–ø–∫–∏ */
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            font-size: 16px; /* –£–í–ï–õ–ò–ß–ï–ù–ù–´–ô —à—Ä–∏—Ñ—Ç */
            font-family: 'Microsoft YaHei', 'Segoe UI', sans-serif;
        }
        .cell:active {
            border: 2px inset #c0c0c0; /* –í–¥–∞–≤–ª–µ–Ω–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ */
        }
        .cell.revealed {
            border: 1px solid #808080; /* –ü–ª–æ—Å–∫–∞—è —Å–µ—Ä–∞—è –≥—Ä–∞–Ω–∏—Ü–∞ */
            background: #c0c0c0; /* –û—Å—Ç–∞—ë—Ç—Å—è —Å–µ—Ä—ã–º */
        }
        .cell.mine.revealed {
            background: #ff0000;
            border: 1px solid #ff0000;
        }
        .cell.flag::before {
            content: "Êóó";
            color: #f00;
            font-weight: bold;
        }
        .cell.highlight {
            background: #ffff99 !important;
        }
        .cell.highlight-flag {
            background: #ffcccc !important;
        }
        /* –•–ê–û–¢–ò–ß–ù–´–ï –°–õ–£–ß–ê–ô–ù–´–ï –¶–í–ï–¢–ê –î–õ–Ø –¶–ò–§–† */
.cell.number-1 { color: #FF6B35; } /* –æ—Ä–∞–Ω–∂–µ–≤—ã–π */
.cell.number-2 { color: #58508D; } /* —Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π */
.cell.number-3 { color: #00A896; } /* –±–∏—Ä—é–∑–æ–≤—ã–π */
.cell.number-4 { color: #F4A261; } /* –ø–µ—Ä—Å–∏–∫–æ–≤—ã–π */
.cell.number-5 { color: #2A9D8F; } /* –∑–µ–ª—ë–Ω–æ-–≥–æ–ª—É–±–æ–π */
.cell.number-6 { color: #E76F51; } /* –∫–æ—Ä–∞–ª–ª–æ–≤—ã–π */
.cell.number-7 { color: #264653; } /* —Ç—ë–º–Ω–æ-—Å–∏–Ω–∏–π */
.cell.number-8 { color: #E9C46A; } /* –∂—ë–ª—Ç—ã–π */
        
        .game-controls {
            margin-top: 20px;
            padding: 15px;
            background: #333;
            border-radius: 10px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .control-group {
            margin: 10px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .control-group label {
            color: #ccc;
            font-size: 14px;
            min-width: 80px;
        }
        .control-group input {
            background: #222;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 6px;
            width: 60px;
            text-align: center;
        }
        .mode-buttons {
            display: flex;
            gap: 8px;
            margin: 10px 0;
        }
        .mode-btn {
            flex: 1;
            padding: 10px;
            background: #555;
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        .mode-btn.active {
            background: #007bff;
            box-shadow: 0 2px 8px rgba(0,123,255,0.3);
        }
        .action-buttons {
            display: flex;
            gap: 10px;
            margin: 12px 0;
        }
        .action-btn {
            flex: 1;
            padding: 10px;
            background: #444;
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .action-btn:hover {
            background: #555;
        }
        .seed-input {
            background: #222;
            color: #fff;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 8px;
            width: 100%;
            margin-top: 8px;
        }
        .game-info {
            margin-top: 12px;
            padding: 10px;
            background: #2a2a2a;
            border-radius: 6px;
            font-size: 12px;
            color: #ccc;
        }
        .seed-info {
            font-family: monospace;
            background: #222;
            padding: 6px;
            border-radius: 4px;
            word-break: break-all;
            margin-top: 6px;
            font-size: 11px;
        }
        .instructions {
            margin-top: 10px;
            padding: 8px;
            background: #2a2a2a;
            border-radius: 6px;
            font-size: 11px;
            color: #aaa;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="game-header">
            <div class="mines-counter">
                Èõ∑: <span id="remainingMines">ÂçÅ</span>
            </div>
            <button class="smiley-btn" onclick="startNewGame()">üá®üá≥</button>
            <div class="timer">
                Êó∂: <span id="gameTimer">„Äá</span>
            </div>
        </div>

        <div class="game-area">
            <div id="gameField"></div>
        </div>

        <div class="instructions">
            <strong>Êìç‰ΩúËØ¥Êòé:</strong><br>
            ‚Ä¢ ÁÇπÂáªÊ®°Âºè: Â∑¶ÈîÆÁøªÂºÄÊ†ºÂ≠ê<br>
            ‚Ä¢ Ê†áËÆ∞Ê®°Âºè: Â∑¶ÈîÆÊîæÁΩÆ/ÁßªÈô§ÊóóÂ∏ú<br>
            ‚Ä¢ Âø´ÈÄüÁÇπÂáª: ÁÇπÂáªÊï∞Â≠óÂêåÊó∂Êåâ‰ΩèÂ∑¶Âè≥ÈîÆ(ÊàñÂèåÂáª)Âø´ÈÄüÊâìÂºÄÂë®Âõ¥
        </div>

        <div class="game-controls">
            <div class="control-group">
                <label>ÂÆΩÂ∫¶:</label>
                <input type="number" id="width" value="9" min="5" max="15">
                
                <label>È´òÂ∫¶:</label>
                <input type="number" id="height" value="9" min="5" max="15">
            </div>
            
            <div class="control-group">
                <label>Âú∞Èõ∑Êï∞:</label>
                <input type="number" id="mines" value="10" min="1" max="30">
            </div>

            <div class="mode-buttons">
                <button class="mode-btn active" onclick="setMode('reveal')">ÁÇπÂáªÊ®°Âºè</button>
                <button class="mode-btn" onclick="setMode('flag')">Ê†áËÆ∞Ê®°Âºè</button>
            </div>

            <div class="action-buttons">
                <button class="action-btn" onclick="startNewGame()">Êñ∞Ê∏∏Êàè</button>
                <button class="action-btn" onclick="generateWithSeed()">ÁßçÂ≠êÊ∏∏Êàè</button>
            </div>

            <input type="text" id="customSeed" class="seed-input" placeholder="ËæìÂÖ•ÁßçÂ≠êÂè∑">

            <div class="game-info">
                <div>Â∑≤ÂºÄ: <span id="revealedCells">„Äá</span>/<span id="totalCells">ÂÖ´ÂçÅ‰∏Ä</span></div>
                <div>ÁßçÂ≠ê: <span class="seed-info" id="currentSeed">-</span></div>
            </div>
        </div>
    </div>

    <script>
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∞—Ä–∞–±—Å–∫–∏—Ö —Ü–∏—Ñ—Ä –≤ –∫–∏—Ç–∞–π—Å–∫–∏–µ
        function toChineseNumber(num) {
            const chineseNumbers = {
                0: '„Äá',
                1: '‰∏Ä',
                2: '‰∫å', 
                3: '‰∏â',
                4: 'Âõõ',
                5: '‰∫î',
                6: 'ÂÖ≠',
                7: '‰∏É',
                8: 'ÂÖ´',
                9: '‰πù'
            };
            
            // –í–°–ï–ì–î–ê –ø—Ä–æ—Å—Ç–æ –∫–æ–º–±–∏–Ω–∞—Ü–∏—è —Ü–∏—Ñ—Ä
            return num.toString().split('').map(digit => chineseNumbers[digit]).join('');
        }

        class MinesweeperGame {
            constructor(width = 9, height = 9, minesCount = 10) {
                this.width = width;
                this.height = height;
                this.minesCount = minesCount;
                this.seed = null;
                this.gameState = 'playing';
                this.revealedCount = 0;
                this.flaggedPositions = new Set();
                this.firstClick = true;
                this.startTime = null;
                this.timer = null;
                this.currentMode = 'reveal';
                this.cellStates = {};
                this.highlightedCells = new Set();
                this.isChordPressed = false;
            }
            
            generateGame(seed = null) {
                if (seed) {
                    this.seed = seed;
                } else {
                    this.seed = this.generateUniqueSeed();
                }
                
                this.setSeed(this.seed);
                this.gameState = 'playing';
                this.revealedCount = 0;
                this.flaggedPositions.clear();
                this.firstClick = true;
                this.cellStates = {};
                this.highlightedCells.clear();
                this.isChordPressed = false;
                this.stopTimer();
                this.startTime = null;
                
                const field = Array(this.height).fill().map(() => 
                    Array(this.width).fill(0)
                );
                
                return {
                    field: field,
                    seed: this.seed,
                    width: this.width,
                    height: this.height
                };
            }
            
            generateUniqueSeed() {
                return Date.now() + Math.floor(Math.random() * 1000000);
            }
            
            setSeed(seed) {
                let x = Math.sin(seed) * 10000;
                this.random = () => {
                    x = Math.sin(x * 10000) * 10000;
                    return x - Math.floor(x);
                };
            }
            
            placeMines(firstX, firstY, field) {
                const minesPositions = [];
                const totalCells = this.width * this.height;
                
                if (this.minesCount >= totalCells) {
                    this.minesCount = totalCells - 1;
                }
                
                while (minesPositions.length < this.minesCount) {
                    const x = Math.floor(this.random() * this.width);
                    const y = Math.floor(this.random() * this.height);
                    
                    if ((x === firstX && y === firstY) || 
                        Math.abs(x - firstX) <= 1 && Math.abs(y - firstY) <= 1) {
                        continue;
                    }
                    
                    const position = `${x},${y}`;
                    if (!minesPositions.includes(position)) {
                        minesPositions.push(position);
                        field[y][x] = -1;
                    }
                }
                
                this.updateNumbers(field, minesPositions);
                return minesPositions;
            }
            
            updateNumbers(field, minesPositions) {
                minesPositions.forEach(pos => {
                    const [x, y] = pos.split(',').map(Number);
                    
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx >= 0 && nx < this.width && 
                                ny >= 0 && ny < this.height && 
                                field[ny][nx] !== -1) {
                                field[ny][nx]++;
                            }
                        }
                    }
                });
            }
            
            revealCell(x, y, field) {
                if (this.gameState !== 'playing') return false;
                if (this.flaggedPositions.has(`${x},${y}`)) return false;
                
                if (this.firstClick) {
                    this.placeMines(x, y, field);
                    this.firstClick = false;
                    this.startTimer();
                }
                
                if (field[y][x] === -1) {
                    this.gameState = 'gameover';
                    this.stopTimer();
                    return true;
                }
                
                if (!this.cellStates[`${x},${y}`]) {
                    this.cellStates[`${x},${y}`] = 'revealed';
                    this.revealedCount++;
                    
                    if (field[y][x] === 0) {
                        this.revealEmptyArea(x, y, field);
                    }
                }
                
                this.checkWinCondition(field);
                return true;
            }
            
            revealEmptyArea(x, y, field) {
                const queue = [[x, y]];
                const visited = new Set();
                
                while (queue.length > 0) {
                    const [cx, cy] = queue.shift();
                    const key = `${cx},${cy}`;
                    
                    if (visited.has(key)) continue;
                    if (this.flaggedPositions.has(key)) continue;
                    
                    visited.add(key);
                    
                    if (!this.cellStates[key]) {
                        this.cellStates[key] = 'revealed';
                        this.revealedCount++;
                    }
                    
                    if (field[cy][cx] === 0) {
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                const nx = cx + dx;
                                const ny = cy + dy;
                                
                                if (nx >= 0 && nx < this.width && 
                                    ny >= 0 && ny < this.height && 
                                    !visited.has(`${nx},${ny}`)) {
                                    queue.push([nx, ny]);
                                }
                            }
                        }
                    }
                }
            }
            
            handleCellClick(x, y) {
                if (this.gameState !== 'playing') return;
                
                const key = `${x},${y}`;
                
                if (this.currentMode === 'reveal') {
                    if (!this.flaggedPositions.has(key)) {
                        this.revealCell(x, y, gameData.field);
                    }
                } else if (this.currentMode === 'flag') {
                    this.toggleFlag(x, y);
                }
            }
            
            toggleFlag(x, y) {
                const key = `${x},${y}`;
                
                if (this.cellStates[key] === 'revealed') return;
                
                if (this.flaggedPositions.has(key)) {
                    this.flaggedPositions.delete(key);
                } else {
                    this.flaggedPositions.add(key);
                }
            }
            
            chordClick(x, y) {
                if (this.gameState !== 'playing') return;
                if (this.cellStates[`${x},${y}`] !== 'revealed') return;
                if (gameData.field[y][x] <= 0) return;
                
                const cellValue = gameData.field[y][x];
                let flagCount = 0;
                const cellsToReveal = [];
                
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
                            const neighborKey = `${nx},${ny}`;
                            if (this.flaggedPositions.has(neighborKey)) {
                                flagCount++;
                            } else if (!this.cellStates[neighborKey]) {
                                cellsToReveal.push([nx, ny]);
                            }
                        }
                    }
                }
                
                if (flagCount === cellValue) {
                    let hitMine = false;
                    
                    for (const [nx, ny] of cellsToReveal) {
                        if (gameData.field[ny][nx] === -1) {
                            hitMine = true;
                        }
                        this.revealCell(nx, ny, gameData.field);
                    }
                    
                    if (hitMine) {
                        this.gameState = 'gameover';
                        this.stopTimer();
                    }
                }
            }
            
            highlightChordArea(x, y) {
                this.highlightedCells.clear();
                
                if (this.cellStates[`${x},${y}`] === 'revealed' && gameData.field[y][x] > 0) {
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx >= 0 && nx < this.width && 
                                ny >= 0 && ny < this.height) {
                                const neighborKey = `${nx},${ny}`;
                                
                                if (!this.cellStates[neighborKey]) {
                                    if (this.flaggedPositions.has(neighborKey)) {
                                        this.highlightedCells.add(neighborKey + '-flag');
                                    } else {
                                        this.highlightedCells.add(neighborKey);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            clearHighlight() {
                this.highlightedCells.clear();
            }
            
            checkWinCondition(field) {
                const totalSafeCells = this.width * this.height - this.minesCount;
                if (this.revealedCount === totalSafeCells) {
                    this.gameState = 'win';
                    this.stopTimer();
                }
            }
            
            getRemainingMines() {
                return this.minesCount - this.flaggedPositions.size;
            }
            
            startTimer() {
                this.startTime = Date.now();
                this.timer = setInterval(updateTimer, 1000);
            }
            
            stopTimer() {
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                }
            }
            
            getElapsedTime() {
                if (!this.startTime) return 0;
                return Math.floor((Date.now() - this.startTime) / 1000);
            }
            
            setMode(mode) {
                this.currentMode = mode;
            }
        }

        let currentGame = null;
        let gameData = null;
        const game = new MinesweeperGame();
        let chordActive = false;

        function startNewGame() {
            const width = parseInt(document.getElementById('width').value) || 9;
            const height = parseInt(document.getElementById('height').value) || 9;
            const mines = parseInt(document.getElementById('mines').value) || 10;
            
            game.width = width;
            game.height = height;
            game.minesCount = mines;
            
            gameData = game.generateGame();
            displayGame();
        }

        function generateWithSeed() {
            const seedInput = document.getElementById('customSeed').value;
            if (!seedInput) {
                alert('ËØ∑ËæìÂÖ•ÁßçÂ≠êÂè∑');
                return;
            }
            
            const width = parseInt(document.getElementById('width').value) || 9;
            const height = parseInt(document.getElementById('height').value) || 9;
            const mines = parseInt(document.getElementById('mines').value) || 10;
            
            game.width = width;
            game.height = height;
            game.minesCount = mines;
            
            const seed = parseInt(seedInput) || seedInput.hashCode();
            gameData = game.generateGame(seed);
            displayGame();
        }

        function setMode(mode) {
            game.setMode(mode);
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        function updateTimer() {
            if (game.gameState === 'playing' && game.startTime) {
                document.getElementById('gameTimer').textContent = toChineseNumber(game.getElapsedTime());
            }
        }

        function handleCellClick(x, y) {
            game.handleCellClick(x, y);
            displayGame();
        }

        function handleChordStart(x, y) {
            if (game.cellStates[`${x},${y}`] === 'revealed' && gameData.field[y][x] > 0) {
                chordActive = true;
                game.highlightChordArea(x, y);
                displayGame();
            }
        }

        function handleChordEnd(x, y) {
            if (chordActive) {
                chordActive = false;
                game.chordClick(x, y);
                game.clearHighlight();
                displayGame();
            }
        }

        function displayGame() {
            const gameField = document.getElementById('gameField');
            const currentSeed = document.getElementById('currentSeed');
            const totalCells = document.getElementById('totalCells');
            const remainingMines = document.getElementById('remainingMines');
            const revealedCells = document.getElementById('revealedCells');
            const gameTimer = document.getElementById('gameTimer');
            
            currentSeed.textContent = gameData.seed;
            totalCells.textContent = toChineseNumber(game.width * game.height);
            remainingMines.textContent = toChineseNumber(game.getRemainingMines());
            revealedCells.textContent = toChineseNumber(game.revealedCount);
            gameTimer.textContent = toChineseNumber(game.getElapsedTime());
            
            const fieldElement = document.createElement('div');
            fieldElement.className = 'field';
            fieldElement.style.gridTemplateColumns = `repeat(${game.width}, 24px)`; // 24px –≤–º–µ—Å—Ç–æ 26px
            
            for (let y = 0; y < game.height; y++) {
                for (let x = 0; x < game.width; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    const key = `${x},${y}`;
                    const value = gameData.field[y][x];
                    const cellState = game.cellStates[key];
                    
                    if (cellState === 'revealed') {
                        cell.classList.add('revealed');
                        if (value === -1) {
                            cell.classList.add('mine');
                            cell.textContent = 'Èõ∑';
                        } else if (value > 0) {
                            cell.classList.add(`number-${value}`);
                            cell.textContent = toChineseNumber(value);
                        }
                    } else {
                        if (game.flaggedPositions.has(key)) {
                            cell.classList.add('flag');
                        }
                    }
                    
                    if (game.highlightedCells.has(key)) {
                        cell.classList.add('highlight');
                    } else if (game.highlightedCells.has(key + '-flag')) {
                        cell.classList.add('highlight-flag');
                    }
                    
                    if (game.gameState === 'gameover' && value === -1 && !game.flaggedPositions.has(key)) {
                        cell.classList.add('revealed', 'mine');
                        cell.textContent = 'Èõ∑';
                    }
                    
                    cell.addEventListener('click', () => handleCellClick(x, y));
                    
                    if (cellState === 'revealed' && value > 0) {
                        cell.addEventListener('mousedown', (e) => {
                            if (e.button === 0) {
                                handleChordStart(x, y);
                            }
                        });
                        cell.addEventListener('mouseup', (e) => {
                            if (e.button === 0) {
                                handleChordEnd(x, y);
                            }
                        });
                    }
                    
                    cell.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        game.toggleFlag(x, y);
                        displayGame();
                    });
                    
                    fieldElement.appendChild(cell);
                }
            }
            
            gameField.innerHTML = '';
            gameField.appendChild(fieldElement);
        }

        String.prototype.hashCode = function() {
            let hash = 0;
            for (let i = 0; i < this.length; i++) {
                const char = this.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash;
        };

        window.onload = startNewGame;
    </script>
</body>
</html>
